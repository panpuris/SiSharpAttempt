
//Игра с пирамидками

void Towers(string with = "1", string on = "3", string some = "2", int count = 3) // 1ый аргумент - шпиль на котором изначально все блины,2ой - шпиль на который необходимо переместить
{                                                                                 // 3ий - промежуточный шпиль, 4ый - колличество блинов
    if (count > 1) Towers(with, some, on, count - 1);
    System.Console.WriteLine($"{with}>>{on}");
    if (count > 1) Towers(some, on, with, count - 1);
}
Towers();
System.Console.WriteLine();

//Обход дерева
//За основу взято данное арифметическое выражение ((4-2)*(1+3))/10
//Где основное знак деления / он разбивает на ((4-2)*(1+3)) и 10
//Далее идет * который является родительским к - и + 
//После этого - и + которые являются родительскими к числам (- к числам 4 и 2) (+ к числам 1 и 3)

string emp = String.Empty;
string[] tree = { emp, "/", "*", "10", "-", "+", emp, emp, "4", "2", "1", "3" };                 // массив представляющий собой это самое дерево
//                 0    1    2    3     4    5    6    7    8    9    10   11
void InOrderTraversal(int pos = 1)                                                               // метод для обхода дерева, в качестве аргумента идет номер позиции с которой идет проверка
{
    if (pos < tree.Length)                                                                       // если позиция вылетела за количество элементов, то рекурсия останавливается
    {
        int left = 2 * pos;                                                                      // направление в левую часть поддерева
        int right = 2 * pos + 1;                                                                 // направление в правую часть поддерева
        if (left < tree.Length && !String.IsNullOrEmpty(tree[left]))                             // делаем проверку наличия левого поддерева и не является ли элемент пустым, 
        {                                                                                        // если нет и там есть как в нашем случае знак *
            InOrderTraversal(left);                                                              // мы запускаем рекурсивную проверку этой ветки
        }
        System.Console.WriteLine(tree[pos]);                                                     // далее мы выводим узел (значение)
        if (right < tree.Length && !String.IsNullOrEmpty(tree[right]))                           // делаем проверку наличия правого поддерева и не является ли элемент пустым
        {                                                                                        // если нет и там есть как в нашем случае 10
            InOrderTraversal(right);                                                             // мы запускаем рекурсивную проверку этой ветки
        } 
    }
}
InOrderTraversal();